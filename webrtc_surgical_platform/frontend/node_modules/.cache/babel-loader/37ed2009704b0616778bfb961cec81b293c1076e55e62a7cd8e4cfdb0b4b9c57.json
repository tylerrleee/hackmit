{"ast":null,"code":"import io from 'socket.io-client';\nclass WebRTCService {\n  constructor() {\n    this.socket = null;\n    this.peerConnections = new Map(); // userId -> RTCPeerConnection\n    this.localStream = null;\n    this.remoteStreams = new Map(); // userId -> MediaStream\n    this.iceServers = [];\n    this.currentRoom = null;\n    this.userId = null;\n    this.listeners = new Map(); // eventName -> Set of callbacks\n\n    // Video call state\n    this.isInVideoCall = false;\n    this.localVideoEnabled = true;\n    this.localAudioEnabled = true;\n    this.roomParticipants = new Map(); // userId -> participant info\n\n    // WebRTC configuration\n    this.rtcConfiguration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10,\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require'\n    };\n\n    // Data channel configuration\n    this.dataChannelConfig = {\n      ordered: true,\n      maxRetransmitTime: 3000\n    };\n\n    // Call management\n    this.activeCalls = new Map(); // callId -> call info\n    this.callQueue = [];\n\n    // Media constraints\n    this.defaultVideoConstraints = {\n      width: {\n        min: 640,\n        ideal: 1280,\n        max: 1920\n      },\n      height: {\n        min: 480,\n        ideal: 720,\n        max: 1080\n      },\n      frameRate: {\n        min: 15,\n        ideal: 30,\n        max: 60\n      }\n    };\n    this.defaultAudioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      sampleRate: 44100\n    };\n  }\n\n  // Initialize the WebRTC service\n  async initialize(serverUrl, authToken) {\n    try {\n      // Connect to signaling server\n      await this.connectToSignalingServer(serverUrl, authToken);\n\n      // Get WebRTC configuration from server\n      await this.loadWebRTCConfiguration();\n      this.setupSocketListeners();\n      console.log('WebRTC Service initialized successfully');\n      this.emit('initialized');\n    } catch (error) {\n      console.error('Failed to initialize WebRTC service:', error);\n      this.emit('error', {\n        type: 'initialization_failed',\n        error\n      });\n      throw error;\n    }\n  }\n\n  // Connect to signaling server\n  async connectToSignalingServer(serverUrl, authToken) {\n    return new Promise((resolve, reject) => {\n      this.socket = io(serverUrl, {\n        auth: {\n          token: authToken\n        },\n        transports: ['websocket', 'polling'],\n        timeout: 10000\n      });\n      this.socket.on('connect', () => {\n        console.log('Connected to signaling server');\n        resolve();\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Failed to connect to signaling server:', error);\n        reject(error);\n      });\n      this.socket.on('disconnect', reason => {\n        console.warn('Disconnected from signaling server:', reason);\n        this.emit('disconnected', {\n          reason\n        });\n      });\n      this.socket.on('error', error => {\n        console.error('Socket error:', error);\n        this.emit('error', {\n          type: 'socket_error',\n          error\n        });\n      });\n    });\n  }\n\n  // Load WebRTC configuration from server\n  async loadWebRTCConfiguration() {\n    try {\n      const response = await fetch('/api/webrtc-config', {\n        headers: {\n          'Authorization': `Bearer ${this.authToken}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Failed to load WebRTC configuration');\n      }\n      const config = await response.json();\n      this.rtcConfiguration.iceServers = config.iceServers;\n    } catch (error) {\n      console.warn('Using default ICE servers due to configuration load error:', error);\n    }\n  }\n\n  // Set up socket event listeners\n  setupSocketListeners() {\n    // Room events\n    this.socket.on('room-joined', this.handleRoomJoined.bind(this));\n    this.socket.on('room-left', this.handleRoomLeft.bind(this));\n    this.socket.on('user-joined', this.handleUserJoined.bind(this));\n    this.socket.on('user-left', this.handleUserLeft.bind(this));\n\n    // WebRTC signaling events\n    this.socket.on('offer', this.handleOffer.bind(this));\n    this.socket.on('answer', this.handleAnswer.bind(this));\n    this.socket.on('ice-candidate', this.handleIceCandidate.bind(this));\n    this.socket.on('renegotiate', this.handleRenegotiation.bind(this));\n\n    // Call management events\n    this.socket.on('call-started', this.handleCallStarted.bind(this));\n    this.socket.on('call-ended', this.handleCallEnded.bind(this));\n    this.socket.on('call-status-update', this.handleCallStatusUpdate.bind(this));\n\n    // Chat and file sharing\n    this.socket.on('chat-message', this.handleChatMessage.bind(this));\n    this.socket.on('file-shared', this.handleFileShared.bind(this));\n\n    // Screen sharing and annotations\n    this.socket.on('screen-share-started', this.handleScreenShareStarted.bind(this));\n    this.socket.on('screen-share-stopped', this.handleScreenShareStopped.bind(this));\n    this.socket.on('annotation', this.handleAnnotation.bind(this));\n  }\n\n  // Media management\n  async getUserMedia(constraints = {}) {\n    try {\n      const mediaConstraints = {\n        video: {\n          ...this.defaultVideoConstraints,\n          ...constraints.video\n        },\n        audio: {\n          ...this.defaultAudioConstraints,\n          ...constraints.audio\n        }\n      };\n      this.localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\n      console.log('Local stream acquired:', {\n        video: this.localStream.getVideoTracks().length > 0,\n        audio: this.localStream.getAudioTracks().length > 0\n      });\n      this.emit('localStreamAcquired', {\n        stream: this.localStream\n      });\n      return this.localStream;\n    } catch (error) {\n      console.error('Failed to get user media:', error);\n      this.emit('error', {\n        type: 'media_access_failed',\n        error\n      });\n      throw error;\n    }\n  }\n  async getDisplayMedia() {\n    try {\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          cursor: 'always',\n          frameRate: {\n            max: 30\n          }\n        },\n        audio: true\n      });\n      console.log('Screen sharing stream acquired');\n      this.emit('screenStreamAcquired', {\n        stream: screenStream\n      });\n      return screenStream;\n    } catch (error) {\n      console.error('Failed to get display media:', error);\n      this.emit('error', {\n        type: 'screen_share_failed',\n        error\n      });\n      throw error;\n    }\n  }\n\n  // Room management\n  async joinRoom(roomId, metadata = {}) {\n    try {\n      var _this$socket;\n      if (!((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.connected)) {\n        throw new Error('Not connected to signaling server');\n      }\n      this.currentRoom = roomId;\n      this.socket.emit('join-room', {\n        roomId,\n        roomType: 'consultation',\n        metadata\n      });\n      console.log(`Joining room: ${roomId}`);\n    } catch (error) {\n      console.error('Failed to join room:', error);\n      throw error;\n    }\n  }\n  async leaveRoom() {\n    try {\n      if (this.currentRoom) {\n        // Close all peer connections\n        for (const [userId, pc] of this.peerConnections) {\n          await this.closePeerConnection(userId);\n        }\n        this.socket.emit('leave-room', {\n          roomId: this.currentRoom\n        });\n        this.currentRoom = null;\n        console.log('Left room');\n        this.emit('roomLeft');\n      }\n    } catch (error) {\n      console.error('Failed to leave room:', error);\n    }\n  }\n\n  // Peer connection management\n  async createPeerConnection(userId) {\n    try {\n      if (this.peerConnections.has(userId)) {\n        await this.closePeerConnection(userId);\n      }\n      const pc = new RTCPeerConnection(this.rtcConfiguration);\n\n      // Add local stream tracks\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          pc.addTrack(track, this.localStream);\n        });\n      }\n\n      // Set up event handlers\n      pc.onicecandidate = event => {\n        if (event.candidate) {\n          this.socket.emit('ice-candidate', {\n            targetUserId: userId,\n            candidate: event.candidate\n          });\n        }\n      };\n      pc.ontrack = event => {\n        console.log('Remote track received from user:', userId);\n        this.emit('remoteStreamReceived', {\n          userId,\n          stream: event.streams[0],\n          track: event.track\n        });\n      };\n      pc.oniceconnectionstatechange = () => {\n        console.log(`ICE connection state for ${userId}:`, pc.iceConnectionState);\n        this.emit('iceConnectionStateChange', {\n          userId,\n          state: pc.iceConnectionState\n        });\n        if (pc.iceConnectionState === 'failed') {\n          this.handleConnectionFailure(userId);\n        }\n      };\n      pc.ondatachannel = event => {\n        this.setupDataChannel(event.channel, userId);\n      };\n\n      // Create data channel\n      const dataChannel = pc.createDataChannel('surgical-guidance', this.dataChannelConfig);\n      this.setupDataChannel(dataChannel, userId);\n      this.peerConnections.set(userId, pc);\n      console.log(`Peer connection created for user: ${userId}`);\n      return pc;\n    } catch (error) {\n      console.error('Failed to create peer connection:', error);\n      throw error;\n    }\n  }\n  setupDataChannel(channel, userId) {\n    channel.onopen = () => {\n      console.log(`Data channel opened with user: ${userId}`);\n      this.emit('dataChannelOpened', {\n        userId,\n        channel\n      });\n    };\n    channel.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        this.emit('dataChannelMessage', {\n          userId,\n          data\n        });\n      } catch (error) {\n        console.error('Failed to parse data channel message:', error);\n      }\n    };\n    channel.onclose = () => {\n      console.log(`Data channel closed with user: ${userId}`);\n      this.emit('dataChannelClosed', {\n        userId\n      });\n    };\n    channel.onerror = error => {\n      console.error(`Data channel error with user ${userId}:`, error);\n    };\n  }\n  async closePeerConnection(userId) {\n    const pc = this.peerConnections.get(userId);\n    if (pc) {\n      pc.close();\n      this.peerConnections.delete(userId);\n      console.log(`Peer connection closed for user: ${userId}`);\n    }\n  }\n\n  // Call management\n  async makeCall(targetUserId, options = {}) {\n    try {\n      if (!this.localStream) {\n        await this.getUserMedia();\n      }\n      const pc = await this.createPeerConnection(targetUserId);\n      const offer = await pc.createOffer(options);\n      await pc.setLocalDescription(offer);\n      const callId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      this.socket.emit('offer', {\n        targetUserId,\n        offer,\n        callId\n      });\n      console.log(`Call initiated to user: ${targetUserId}`);\n      this.emit('callInitiated', {\n        targetUserId,\n        callId\n      });\n    } catch (error) {\n      console.error('Failed to make call:', error);\n      this.emit('error', {\n        type: 'call_failed',\n        error\n      });\n      throw error;\n    }\n  }\n  async endCall(callId) {\n    try {\n      this.socket.emit('end-call', {\n        callId\n      });\n\n      // Close relevant peer connections\n      for (const [userId, pc] of this.peerConnections) {\n        await this.closePeerConnection(userId);\n      }\n      this.emit('callEnded', {\n        callId\n      });\n    } catch (error) {\n      console.error('Failed to end call:', error);\n    }\n  }\n\n  // Socket event handlers\n  handleRoomJoined(data) {\n    console.log('Room joined:', data);\n    this.emit('roomJoined', data);\n  }\n  handleRoomLeft(data) {\n    console.log('Room left:', data);\n    this.emit('roomLeft', data);\n  }\n  handleUserJoined(data) {\n    console.log('User joined room:', data);\n    this.emit('userJoined', data);\n  }\n  handleUserLeft(data) {\n    console.log('User left room:', data);\n    this.closePeerConnection(data.userId);\n    this.emit('userLeft', data);\n  }\n  async handleOffer(data) {\n    try {\n      const {\n        fromUserId,\n        offer,\n        callId\n      } = data;\n      console.log('Received offer from:', fromUserId);\n      const pc = await this.createPeerConnection(fromUserId);\n      await pc.setRemoteDescription(new RTCSessionDescription(offer));\n      if (!this.localStream) {\n        await this.getUserMedia();\n        // Re-add tracks to peer connection\n        this.localStream.getTracks().forEach(track => {\n          pc.addTrack(track, this.localStream);\n        });\n      }\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n      this.socket.emit('answer', {\n        targetUserId: fromUserId,\n        answer,\n        callId\n      });\n      this.emit('callReceived', {\n        fromUserId,\n        callId\n      });\n    } catch (error) {\n      console.error('Failed to handle offer:', error);\n      this.emit('error', {\n        type: 'offer_handling_failed',\n        error\n      });\n    }\n  }\n  async handleAnswer(data) {\n    try {\n      const {\n        fromUserId,\n        answer\n      } = data;\n      console.log('Received answer from:', fromUserId);\n      const pc = this.peerConnections.get(fromUserId);\n      if (pc) {\n        await pc.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log('Answer processed successfully');\n      }\n    } catch (error) {\n      console.error('Failed to handle answer:', error);\n    }\n  }\n  async handleIceCandidate(data) {\n    try {\n      const {\n        fromUserId,\n        candidate\n      } = data;\n      const pc = this.peerConnections.get(fromUserId);\n      if (pc && candidate) {\n        await pc.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Failed to handle ICE candidate:', error);\n    }\n  }\n  async handleRenegotiation(data) {\n    try {\n      const {\n        fromUserId,\n        offer\n      } = data;\n      console.log('Renegotiation request from:', fromUserId);\n      const pc = this.peerConnections.get(fromUserId);\n      if (pc) {\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        this.socket.emit('answer', {\n          targetUserId: fromUserId,\n          answer\n        });\n      }\n    } catch (error) {\n      console.error('Failed to handle renegotiation:', error);\n    }\n  }\n  handleCallStarted(data) {\n    console.log('Call started:', data);\n    this.activeCalls.set(data.callId, data);\n    this.emit('callStarted', data);\n  }\n  handleCallEnded(data) {\n    console.log('Call ended:', data);\n    this.activeCalls.delete(data.callId);\n    this.emit('callEnded', data);\n  }\n  handleCallStatusUpdate(data) {\n    this.emit('callStatusUpdate', data);\n  }\n  handleChatMessage(data) {\n    this.emit('chatMessage', data);\n  }\n  handleFileShared(data) {\n    this.emit('fileShared', data);\n  }\n  handleScreenShareStarted(data) {\n    this.emit('screenShareStarted', data);\n  }\n  handleScreenShareStopped(data) {\n    this.emit('screenShareStopped', data);\n  }\n  handleAnnotation(data) {\n    this.emit('annotation', data);\n  }\n\n  // Connection failure handling\n  async handleConnectionFailure(userId) {\n    console.warn(`Connection failure with user: ${userId}`);\n    try {\n      // Attempt to reconnect\n      setTimeout(async () => {\n        if (this.currentRoom) {\n          await this.createPeerConnection(userId);\n        }\n      }, 5000);\n    } catch (error) {\n      console.error('Failed to recover connection:', error);\n    }\n  }\n\n  // Utility methods\n  sendDataChannelMessage(userId, data) {\n    const pc = this.peerConnections.get(userId);\n    if (pc) {\n      var _Array$from$find;\n      const channel = pc.createDataChannel ? pc.createDataChannel('surgical-guidance', this.dataChannelConfig) : (_Array$from$find = Array.from(pc.getReceivers()).find(r => r.channel)) === null || _Array$from$find === void 0 ? void 0 : _Array$from$find.channel;\n      if (channel && channel.readyState === 'open') {\n        channel.send(JSON.stringify(data));\n      }\n    }\n  }\n\n  // Event handling\n  on(eventName, callback) {\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, new Set());\n    }\n    this.listeners.get(eventName).add(callback);\n  }\n  off(eventName, callback) {\n    if (this.listeners.has(eventName)) {\n      this.listeners.get(eventName).delete(callback);\n    }\n  }\n  emit(eventName, data) {\n    if (this.listeners.has(eventName)) {\n      this.listeners.get(eventName).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for ${eventName}:`, error);\n        }\n      });\n    }\n  }\n\n  // Cleanup\n  disconnect() {\n    // Close all peer connections\n    for (const [userId] of this.peerConnections) {\n      this.closePeerConnection(userId);\n    }\n\n    // Stop local stream\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n\n    // Disconnect socket\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    // Clear listeners\n    this.listeners.clear();\n    console.log('WebRTC Service disconnected');\n  }\n\n  // Get connection statistics\n  async getConnectionStats() {\n    const stats = new Map();\n    for (const [userId, pc] of this.peerConnections) {\n      try {\n        const peerStats = await pc.getStats();\n        stats.set(userId, peerStats);\n      } catch (error) {\n        console.error(`Failed to get stats for user ${userId}:`, error);\n      }\n    }\n    return stats;\n  }\n\n  // === VIDEO CALL MANAGEMENT ===\n\n  // Start video call for the room\n  async startRoomVideoCall() {\n    try {\n      console.log('Starting room video call...');\n      this.isInVideoCall = true;\n\n      // Get local media stream\n      await this.getUserMedia({\n        video: this.defaultVideoConstraints,\n        audio: this.defaultAudioConstraints\n      });\n\n      // Create peer connections with all current room participants\n      for (const [userId] of this.roomParticipants) {\n        if (userId !== this.userId) {\n          await this.createPeerConnection(userId);\n          await this.makeCall(userId);\n        }\n      }\n      this.emit('video-call-started');\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Failed to start room video call:', error);\n      this.emit('error', {\n        type: 'video_call_start_failed',\n        error\n      });\n      throw error;\n    }\n  }\n\n  // End video call for the room\n  async endRoomVideoCall() {\n    try {\n      console.log('Ending room video call...');\n      this.isInVideoCall = false;\n\n      // Stop local stream\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => track.stop());\n        this.localStream = null;\n      }\n\n      // Close all peer connections\n      for (const [userId] of this.peerConnections) {\n        this.closePeerConnection(userId);\n      }\n\n      // Clear remote streams\n      this.remoteStreams.clear();\n      this.emit('video-call-ended');\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Failed to end room video call:', error);\n      this.emit('error', {\n        type: 'video_call_end_failed',\n        error\n      });\n      throw error;\n    }\n  }\n\n  // Toggle local video\n  toggleLocalVideo() {\n    if (this.localStream) {\n      const videoTrack = this.localStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n        this.localVideoEnabled = videoTrack.enabled;\n        this.emit('local-video-toggled', {\n          enabled: this.localVideoEnabled\n        });\n        return this.localVideoEnabled;\n      }\n    }\n    return false;\n  }\n\n  // Toggle local audio\n  toggleLocalAudio() {\n    if (this.localStream) {\n      const audioTrack = this.localStream.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        this.localAudioEnabled = audioTrack.enabled;\n        this.emit('local-audio-toggled', {\n          enabled: this.localAudioEnabled\n        });\n        return this.localAudioEnabled;\n      }\n    }\n    return false;\n  }\n\n  // Get local stream for video element\n  getLocalStream() {\n    return this.localStream;\n  }\n\n  // Get remote stream by user ID\n  getRemoteStream(userId) {\n    return this.remoteStreams.get(userId);\n  }\n\n  // Get all remote streams\n  getAllRemoteStreams() {\n    return new Map(this.remoteStreams);\n  }\n\n  // Handle new user joining room during video call\n  async handleUserJoinedDuringCall(userId, userInfo) {\n    if (this.isInVideoCall && userId !== this.userId) {\n      this.roomParticipants.set(userId, userInfo);\n\n      // Create peer connection and initiate call\n      await this.createPeerConnection(userId);\n      await this.makeCall(userId);\n    }\n  }\n\n  // Enhanced handleUserJoined for video calls\n  handleUserJoined(data) {\n    const {\n      user\n    } = data;\n    console.log(`User joined room: ${user.name}`);\n    this.roomParticipants.set(user.id, user);\n\n    // If we're in a video call, establish peer connection\n    if (this.isInVideoCall) {\n      this.handleUserJoinedDuringCall(user.id, user);\n    }\n    this.emit('user-joined', data);\n  }\n\n  // Enhanced handleUserLeft for video calls  \n  handleUserLeft(data) {\n    const {\n      userId\n    } = data;\n    console.log(`User left room: ${userId}`);\n    this.roomParticipants.delete(userId);\n\n    // Clean up peer connection and remote stream\n    if (this.peerConnections.has(userId)) {\n      this.closePeerConnection(userId);\n    }\n    if (this.remoteStreams.has(userId)) {\n      const stream = this.remoteStreams.get(userId);\n      stream.getTracks().forEach(track => track.stop());\n      this.remoteStreams.delete(userId);\n    }\n    this.emit('user-left', data);\n  }\n\n  // Enhanced createPeerConnection to handle remote streams\n  async createPeerConnection(userId) {\n    try {\n      if (this.peerConnections.has(userId)) {\n        console.log(`Peer connection already exists for user: ${userId}`);\n        return this.peerConnections.get(userId);\n      }\n      const peerConnection = new RTCPeerConnection(this.rtcConfiguration);\n\n      // Add local stream tracks if available\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n\n      // Handle incoming remote stream\n      peerConnection.ontrack = event => {\n        console.log('Received remote stream from user:', userId);\n        const [remoteStream] = event.streams;\n        this.remoteStreams.set(userId, remoteStream);\n        this.emit('remote-stream-added', {\n          userId,\n          stream: remoteStream\n        });\n      };\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          this.socket.emit('ice-candidate', {\n            candidate: event.candidate,\n            targetUserId: userId\n          });\n        }\n      };\n\n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state with ${userId}:`, peerConnection.connectionState);\n        this.emit('connection-state-changed', {\n          userId,\n          state: peerConnection.connectionState\n        });\n        if (peerConnection.connectionState === 'failed') {\n          this.closePeerConnection(userId);\n        }\n      };\n      this.peerConnections.set(userId, peerConnection);\n      console.log(`Created peer connection for user: ${userId}`);\n      return peerConnection;\n    } catch (error) {\n      console.error(`Failed to create peer connection for user ${userId}:`, error);\n      this.emit('error', {\n        type: 'peer_connection_failed',\n        userId,\n        error\n      });\n      throw error;\n    }\n  }\n}\nexport default WebRTCService;","map":{"version":3,"names":["io","WebRTCService","constructor","socket","peerConnections","Map","localStream","remoteStreams","iceServers","currentRoom","userId","listeners","isInVideoCall","localVideoEnabled","localAudioEnabled","roomParticipants","rtcConfiguration","urls","iceCandidatePoolSize","bundlePolicy","rtcpMuxPolicy","dataChannelConfig","ordered","maxRetransmitTime","activeCalls","callQueue","defaultVideoConstraints","width","min","ideal","max","height","frameRate","defaultAudioConstraints","echoCancellation","noiseSuppression","autoGainControl","sampleRate","initialize","serverUrl","authToken","connectToSignalingServer","loadWebRTCConfiguration","setupSocketListeners","console","log","emit","error","type","Promise","resolve","reject","auth","token","transports","timeout","on","reason","warn","response","fetch","headers","ok","Error","config","json","handleRoomJoined","bind","handleRoomLeft","handleUserJoined","handleUserLeft","handleOffer","handleAnswer","handleIceCandidate","handleRenegotiation","handleCallStarted","handleCallEnded","handleCallStatusUpdate","handleChatMessage","handleFileShared","handleScreenShareStarted","handleScreenShareStopped","handleAnnotation","getUserMedia","constraints","mediaConstraints","video","audio","navigator","mediaDevices","getVideoTracks","length","getAudioTracks","stream","getDisplayMedia","screenStream","cursor","joinRoom","roomId","metadata","_this$socket","connected","roomType","leaveRoom","pc","closePeerConnection","createPeerConnection","has","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","event","candidate","targetUserId","ontrack","streams","oniceconnectionstatechange","iceConnectionState","state","handleConnectionFailure","ondatachannel","setupDataChannel","channel","dataChannel","createDataChannel","set","onopen","onmessage","data","JSON","parse","onclose","onerror","get","close","delete","makeCall","options","offer","createOffer","setLocalDescription","callId","Date","now","Math","random","toString","substr","endCall","fromUserId","setRemoteDescription","RTCSessionDescription","answer","createAnswer","addIceCandidate","RTCIceCandidate","setTimeout","sendDataChannelMessage","_Array$from$find","Array","from","getReceivers","find","r","readyState","send","stringify","eventName","callback","Set","add","off","disconnect","stop","clear","getConnectionStats","stats","peerStats","getStats","startRoomVideoCall","success","endRoomVideoCall","toggleLocalVideo","videoTrack","enabled","toggleLocalAudio","audioTrack","getLocalStream","getRemoteStream","getAllRemoteStreams","handleUserJoinedDuringCall","userInfo","user","name","id","peerConnection","remoteStream","onconnectionstatechange","connectionState"],"sources":["/Users/tienle/Documents/Coding/hackmit/webrtc_surgical_platform/frontend/src/services/WebRTCService.js"],"sourcesContent":["import io from 'socket.io-client';\n\nclass WebRTCService {\n    constructor() {\n        this.socket = null;\n        this.peerConnections = new Map(); // userId -> RTCPeerConnection\n        this.localStream = null;\n        this.remoteStreams = new Map(); // userId -> MediaStream\n        this.iceServers = [];\n        this.currentRoom = null;\n        this.userId = null;\n        this.listeners = new Map(); // eventName -> Set of callbacks\n        \n        // Video call state\n        this.isInVideoCall = false;\n        this.localVideoEnabled = true;\n        this.localAudioEnabled = true;\n        this.roomParticipants = new Map(); // userId -> participant info\n        \n        // WebRTC configuration\n        this.rtcConfiguration = {\n            iceServers: [\n                { urls: 'stun:stun.l.google.com:19302' }\n            ],\n            iceCandidatePoolSize: 10,\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require'\n        };\n\n        // Data channel configuration\n        this.dataChannelConfig = {\n            ordered: true,\n            maxRetransmitTime: 3000\n        };\n\n        // Call management\n        this.activeCalls = new Map(); // callId -> call info\n        this.callQueue = [];\n        \n        // Media constraints\n        this.defaultVideoConstraints = {\n            width: { min: 640, ideal: 1280, max: 1920 },\n            height: { min: 480, ideal: 720, max: 1080 },\n            frameRate: { min: 15, ideal: 30, max: 60 }\n        };\n\n        this.defaultAudioConstraints = {\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n            sampleRate: 44100\n        };\n    }\n\n    // Initialize the WebRTC service\n    async initialize(serverUrl, authToken) {\n        try {\n            // Connect to signaling server\n            await this.connectToSignalingServer(serverUrl, authToken);\n            \n            // Get WebRTC configuration from server\n            await this.loadWebRTCConfiguration();\n            \n            this.setupSocketListeners();\n            \n            console.log('WebRTC Service initialized successfully');\n            this.emit('initialized');\n            \n        } catch (error) {\n            console.error('Failed to initialize WebRTC service:', error);\n            this.emit('error', { type: 'initialization_failed', error });\n            throw error;\n        }\n    }\n\n    // Connect to signaling server\n    async connectToSignalingServer(serverUrl, authToken) {\n        return new Promise((resolve, reject) => {\n            this.socket = io(serverUrl, {\n                auth: {\n                    token: authToken\n                },\n                transports: ['websocket', 'polling'],\n                timeout: 10000\n            });\n\n            this.socket.on('connect', () => {\n                console.log('Connected to signaling server');\n                resolve();\n            });\n\n            this.socket.on('connect_error', (error) => {\n                console.error('Failed to connect to signaling server:', error);\n                reject(error);\n            });\n\n            this.socket.on('disconnect', (reason) => {\n                console.warn('Disconnected from signaling server:', reason);\n                this.emit('disconnected', { reason });\n            });\n\n            this.socket.on('error', (error) => {\n                console.error('Socket error:', error);\n                this.emit('error', { type: 'socket_error', error });\n            });\n        });\n    }\n\n    // Load WebRTC configuration from server\n    async loadWebRTCConfiguration() {\n        try {\n            const response = await fetch('/api/webrtc-config', {\n                headers: {\n                    'Authorization': `Bearer ${this.authToken}`,\n                    'Content-Type': 'application/json'\n                }\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to load WebRTC configuration');\n            }\n\n            const config = await response.json();\n            this.rtcConfiguration.iceServers = config.iceServers;\n            \n        } catch (error) {\n            console.warn('Using default ICE servers due to configuration load error:', error);\n        }\n    }\n\n    // Set up socket event listeners\n    setupSocketListeners() {\n        // Room events\n        this.socket.on('room-joined', this.handleRoomJoined.bind(this));\n        this.socket.on('room-left', this.handleRoomLeft.bind(this));\n        this.socket.on('user-joined', this.handleUserJoined.bind(this));\n        this.socket.on('user-left', this.handleUserLeft.bind(this));\n\n        // WebRTC signaling events\n        this.socket.on('offer', this.handleOffer.bind(this));\n        this.socket.on('answer', this.handleAnswer.bind(this));\n        this.socket.on('ice-candidate', this.handleIceCandidate.bind(this));\n        this.socket.on('renegotiate', this.handleRenegotiation.bind(this));\n\n        // Call management events\n        this.socket.on('call-started', this.handleCallStarted.bind(this));\n        this.socket.on('call-ended', this.handleCallEnded.bind(this));\n        this.socket.on('call-status-update', this.handleCallStatusUpdate.bind(this));\n\n        // Chat and file sharing\n        this.socket.on('chat-message', this.handleChatMessage.bind(this));\n        this.socket.on('file-shared', this.handleFileShared.bind(this));\n\n        // Screen sharing and annotations\n        this.socket.on('screen-share-started', this.handleScreenShareStarted.bind(this));\n        this.socket.on('screen-share-stopped', this.handleScreenShareStopped.bind(this));\n        this.socket.on('annotation', this.handleAnnotation.bind(this));\n    }\n\n    // Media management\n    async getUserMedia(constraints = {}) {\n        try {\n            const mediaConstraints = {\n                video: {\n                    ...this.defaultVideoConstraints,\n                    ...constraints.video\n                },\n                audio: {\n                    ...this.defaultAudioConstraints,\n                    ...constraints.audio\n                }\n            };\n\n            this.localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\n            \n            console.log('Local stream acquired:', {\n                video: this.localStream.getVideoTracks().length > 0,\n                audio: this.localStream.getAudioTracks().length > 0\n            });\n\n            this.emit('localStreamAcquired', { stream: this.localStream });\n            return this.localStream;\n\n        } catch (error) {\n            console.error('Failed to get user media:', error);\n            this.emit('error', { type: 'media_access_failed', error });\n            throw error;\n        }\n    }\n\n    async getDisplayMedia() {\n        try {\n            const screenStream = await navigator.mediaDevices.getDisplayMedia({\n                video: {\n                    cursor: 'always',\n                    frameRate: { max: 30 }\n                },\n                audio: true\n            });\n\n            console.log('Screen sharing stream acquired');\n            this.emit('screenStreamAcquired', { stream: screenStream });\n            return screenStream;\n\n        } catch (error) {\n            console.error('Failed to get display media:', error);\n            this.emit('error', { type: 'screen_share_failed', error });\n            throw error;\n        }\n    }\n\n    // Room management\n    async joinRoom(roomId, metadata = {}) {\n        try {\n            if (!this.socket?.connected) {\n                throw new Error('Not connected to signaling server');\n            }\n\n            this.currentRoom = roomId;\n            \n            this.socket.emit('join-room', {\n                roomId,\n                roomType: 'consultation',\n                metadata\n            });\n\n            console.log(`Joining room: ${roomId}`);\n\n        } catch (error) {\n            console.error('Failed to join room:', error);\n            throw error;\n        }\n    }\n\n    async leaveRoom() {\n        try {\n            if (this.currentRoom) {\n                // Close all peer connections\n                for (const [userId, pc] of this.peerConnections) {\n                    await this.closePeerConnection(userId);\n                }\n\n                this.socket.emit('leave-room', { roomId: this.currentRoom });\n                this.currentRoom = null;\n                \n                console.log('Left room');\n                this.emit('roomLeft');\n            }\n        } catch (error) {\n            console.error('Failed to leave room:', error);\n        }\n    }\n\n    // Peer connection management\n    async createPeerConnection(userId) {\n        try {\n            if (this.peerConnections.has(userId)) {\n                await this.closePeerConnection(userId);\n            }\n\n            const pc = new RTCPeerConnection(this.rtcConfiguration);\n            \n            // Add local stream tracks\n            if (this.localStream) {\n                this.localStream.getTracks().forEach(track => {\n                    pc.addTrack(track, this.localStream);\n                });\n            }\n\n            // Set up event handlers\n            pc.onicecandidate = (event) => {\n                if (event.candidate) {\n                    this.socket.emit('ice-candidate', {\n                        targetUserId: userId,\n                        candidate: event.candidate\n                    });\n                }\n            };\n\n            pc.ontrack = (event) => {\n                console.log('Remote track received from user:', userId);\n                this.emit('remoteStreamReceived', {\n                    userId,\n                    stream: event.streams[0],\n                    track: event.track\n                });\n            };\n\n            pc.oniceconnectionstatechange = () => {\n                console.log(`ICE connection state for ${userId}:`, pc.iceConnectionState);\n                this.emit('iceConnectionStateChange', {\n                    userId,\n                    state: pc.iceConnectionState\n                });\n\n                if (pc.iceConnectionState === 'failed') {\n                    this.handleConnectionFailure(userId);\n                }\n            };\n\n            pc.ondatachannel = (event) => {\n                this.setupDataChannel(event.channel, userId);\n            };\n\n            // Create data channel\n            const dataChannel = pc.createDataChannel('surgical-guidance', this.dataChannelConfig);\n            this.setupDataChannel(dataChannel, userId);\n\n            this.peerConnections.set(userId, pc);\n            console.log(`Peer connection created for user: ${userId}`);\n\n            return pc;\n\n        } catch (error) {\n            console.error('Failed to create peer connection:', error);\n            throw error;\n        }\n    }\n\n    setupDataChannel(channel, userId) {\n        channel.onopen = () => {\n            console.log(`Data channel opened with user: ${userId}`);\n            this.emit('dataChannelOpened', { userId, channel });\n        };\n\n        channel.onmessage = (event) => {\n            try {\n                const data = JSON.parse(event.data);\n                this.emit('dataChannelMessage', { userId, data });\n            } catch (error) {\n                console.error('Failed to parse data channel message:', error);\n            }\n        };\n\n        channel.onclose = () => {\n            console.log(`Data channel closed with user: ${userId}`);\n            this.emit('dataChannelClosed', { userId });\n        };\n\n        channel.onerror = (error) => {\n            console.error(`Data channel error with user ${userId}:`, error);\n        };\n    }\n\n    async closePeerConnection(userId) {\n        const pc = this.peerConnections.get(userId);\n        if (pc) {\n            pc.close();\n            this.peerConnections.delete(userId);\n            console.log(`Peer connection closed for user: ${userId}`);\n        }\n    }\n\n    // Call management\n    async makeCall(targetUserId, options = {}) {\n        try {\n            if (!this.localStream) {\n                await this.getUserMedia();\n            }\n\n            const pc = await this.createPeerConnection(targetUserId);\n            const offer = await pc.createOffer(options);\n            await pc.setLocalDescription(offer);\n\n            const callId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n            \n            this.socket.emit('offer', {\n                targetUserId,\n                offer,\n                callId\n            });\n\n            console.log(`Call initiated to user: ${targetUserId}`);\n            this.emit('callInitiated', { targetUserId, callId });\n\n        } catch (error) {\n            console.error('Failed to make call:', error);\n            this.emit('error', { type: 'call_failed', error });\n            throw error;\n        }\n    }\n\n    async endCall(callId) {\n        try {\n            this.socket.emit('end-call', { callId });\n            \n            // Close relevant peer connections\n            for (const [userId, pc] of this.peerConnections) {\n                await this.closePeerConnection(userId);\n            }\n\n            this.emit('callEnded', { callId });\n\n        } catch (error) {\n            console.error('Failed to end call:', error);\n        }\n    }\n\n    // Socket event handlers\n    handleRoomJoined(data) {\n        console.log('Room joined:', data);\n        this.emit('roomJoined', data);\n    }\n\n    handleRoomLeft(data) {\n        console.log('Room left:', data);\n        this.emit('roomLeft', data);\n    }\n\n    handleUserJoined(data) {\n        console.log('User joined room:', data);\n        this.emit('userJoined', data);\n    }\n\n    handleUserLeft(data) {\n        console.log('User left room:', data);\n        this.closePeerConnection(data.userId);\n        this.emit('userLeft', data);\n    }\n\n    async handleOffer(data) {\n        try {\n            const { fromUserId, offer, callId } = data;\n            console.log('Received offer from:', fromUserId);\n\n            const pc = await this.createPeerConnection(fromUserId);\n            await pc.setRemoteDescription(new RTCSessionDescription(offer));\n\n            if (!this.localStream) {\n                await this.getUserMedia();\n                // Re-add tracks to peer connection\n                this.localStream.getTracks().forEach(track => {\n                    pc.addTrack(track, this.localStream);\n                });\n            }\n\n            const answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n\n            this.socket.emit('answer', {\n                targetUserId: fromUserId,\n                answer,\n                callId\n            });\n\n            this.emit('callReceived', { fromUserId, callId });\n\n        } catch (error) {\n            console.error('Failed to handle offer:', error);\n            this.emit('error', { type: 'offer_handling_failed', error });\n        }\n    }\n\n    async handleAnswer(data) {\n        try {\n            const { fromUserId, answer } = data;\n            console.log('Received answer from:', fromUserId);\n\n            const pc = this.peerConnections.get(fromUserId);\n            if (pc) {\n                await pc.setRemoteDescription(new RTCSessionDescription(answer));\n                console.log('Answer processed successfully');\n            }\n\n        } catch (error) {\n            console.error('Failed to handle answer:', error);\n        }\n    }\n\n    async handleIceCandidate(data) {\n        try {\n            const { fromUserId, candidate } = data;\n            const pc = this.peerConnections.get(fromUserId);\n            \n            if (pc && candidate) {\n                await pc.addIceCandidate(new RTCIceCandidate(candidate));\n            }\n\n        } catch (error) {\n            console.error('Failed to handle ICE candidate:', error);\n        }\n    }\n\n    async handleRenegotiation(data) {\n        try {\n            const { fromUserId, offer } = data;\n            console.log('Renegotiation request from:', fromUserId);\n\n            const pc = this.peerConnections.get(fromUserId);\n            if (pc) {\n                await pc.setRemoteDescription(new RTCSessionDescription(offer));\n                const answer = await pc.createAnswer();\n                await pc.setLocalDescription(answer);\n\n                this.socket.emit('answer', {\n                    targetUserId: fromUserId,\n                    answer\n                });\n            }\n\n        } catch (error) {\n            console.error('Failed to handle renegotiation:', error);\n        }\n    }\n\n    handleCallStarted(data) {\n        console.log('Call started:', data);\n        this.activeCalls.set(data.callId, data);\n        this.emit('callStarted', data);\n    }\n\n    handleCallEnded(data) {\n        console.log('Call ended:', data);\n        this.activeCalls.delete(data.callId);\n        this.emit('callEnded', data);\n    }\n\n    handleCallStatusUpdate(data) {\n        this.emit('callStatusUpdate', data);\n    }\n\n    handleChatMessage(data) {\n        this.emit('chatMessage', data);\n    }\n\n    handleFileShared(data) {\n        this.emit('fileShared', data);\n    }\n\n    handleScreenShareStarted(data) {\n        this.emit('screenShareStarted', data);\n    }\n\n    handleScreenShareStopped(data) {\n        this.emit('screenShareStopped', data);\n    }\n\n    handleAnnotation(data) {\n        this.emit('annotation', data);\n    }\n\n    // Connection failure handling\n    async handleConnectionFailure(userId) {\n        console.warn(`Connection failure with user: ${userId}`);\n        \n        try {\n            // Attempt to reconnect\n            setTimeout(async () => {\n                if (this.currentRoom) {\n                    await this.createPeerConnection(userId);\n                }\n            }, 5000);\n        } catch (error) {\n            console.error('Failed to recover connection:', error);\n        }\n    }\n\n    // Utility methods\n    sendDataChannelMessage(userId, data) {\n        const pc = this.peerConnections.get(userId);\n        if (pc) {\n            const channel = pc.createDataChannel ? \n                pc.createDataChannel('surgical-guidance', this.dataChannelConfig) :\n                Array.from(pc.getReceivers()).find(r => r.channel)?.channel;\n                \n            if (channel && channel.readyState === 'open') {\n                channel.send(JSON.stringify(data));\n            }\n        }\n    }\n\n    // Event handling\n    on(eventName, callback) {\n        if (!this.listeners.has(eventName)) {\n            this.listeners.set(eventName, new Set());\n        }\n        this.listeners.get(eventName).add(callback);\n    }\n\n    off(eventName, callback) {\n        if (this.listeners.has(eventName)) {\n            this.listeners.get(eventName).delete(callback);\n        }\n    }\n\n    emit(eventName, data) {\n        if (this.listeners.has(eventName)) {\n            this.listeners.get(eventName).forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`Error in event listener for ${eventName}:`, error);\n                }\n            });\n        }\n    }\n\n    // Cleanup\n    disconnect() {\n        // Close all peer connections\n        for (const [userId] of this.peerConnections) {\n            this.closePeerConnection(userId);\n        }\n\n        // Stop local stream\n        if (this.localStream) {\n            this.localStream.getTracks().forEach(track => track.stop());\n            this.localStream = null;\n        }\n\n        // Disconnect socket\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n\n        // Clear listeners\n        this.listeners.clear();\n\n        console.log('WebRTC Service disconnected');\n    }\n\n    // Get connection statistics\n    async getConnectionStats() {\n        const stats = new Map();\n        \n        for (const [userId, pc] of this.peerConnections) {\n            try {\n                const peerStats = await pc.getStats();\n                stats.set(userId, peerStats);\n            } catch (error) {\n                console.error(`Failed to get stats for user ${userId}:`, error);\n            }\n        }\n\n        return stats;\n    }\n\n    // === VIDEO CALL MANAGEMENT ===\n    \n    // Start video call for the room\n    async startRoomVideoCall() {\n        try {\n            console.log('Starting room video call...');\n            this.isInVideoCall = true;\n            \n            // Get local media stream\n            await this.getUserMedia({\n                video: this.defaultVideoConstraints,\n                audio: this.defaultAudioConstraints\n            });\n            \n            // Create peer connections with all current room participants\n            for (const [userId] of this.roomParticipants) {\n                if (userId !== this.userId) {\n                    await this.createPeerConnection(userId);\n                    await this.makeCall(userId);\n                }\n            }\n            \n            this.emit('video-call-started');\n            return { success: true };\n            \n        } catch (error) {\n            console.error('Failed to start room video call:', error);\n            this.emit('error', { type: 'video_call_start_failed', error });\n            throw error;\n        }\n    }\n    \n    // End video call for the room\n    async endRoomVideoCall() {\n        try {\n            console.log('Ending room video call...');\n            this.isInVideoCall = false;\n            \n            // Stop local stream\n            if (this.localStream) {\n                this.localStream.getTracks().forEach(track => track.stop());\n                this.localStream = null;\n            }\n            \n            // Close all peer connections\n            for (const [userId] of this.peerConnections) {\n                this.closePeerConnection(userId);\n            }\n            \n            // Clear remote streams\n            this.remoteStreams.clear();\n            \n            this.emit('video-call-ended');\n            return { success: true };\n            \n        } catch (error) {\n            console.error('Failed to end room video call:', error);\n            this.emit('error', { type: 'video_call_end_failed', error });\n            throw error;\n        }\n    }\n    \n    // Toggle local video\n    toggleLocalVideo() {\n        if (this.localStream) {\n            const videoTrack = this.localStream.getVideoTracks()[0];\n            if (videoTrack) {\n                videoTrack.enabled = !videoTrack.enabled;\n                this.localVideoEnabled = videoTrack.enabled;\n                this.emit('local-video-toggled', { enabled: this.localVideoEnabled });\n                return this.localVideoEnabled;\n            }\n        }\n        return false;\n    }\n    \n    // Toggle local audio\n    toggleLocalAudio() {\n        if (this.localStream) {\n            const audioTrack = this.localStream.getAudioTracks()[0];\n            if (audioTrack) {\n                audioTrack.enabled = !audioTrack.enabled;\n                this.localAudioEnabled = audioTrack.enabled;\n                this.emit('local-audio-toggled', { enabled: this.localAudioEnabled });\n                return this.localAudioEnabled;\n            }\n        }\n        return false;\n    }\n    \n    // Get local stream for video element\n    getLocalStream() {\n        return this.localStream;\n    }\n    \n    // Get remote stream by user ID\n    getRemoteStream(userId) {\n        return this.remoteStreams.get(userId);\n    }\n    \n    // Get all remote streams\n    getAllRemoteStreams() {\n        return new Map(this.remoteStreams);\n    }\n    \n    // Handle new user joining room during video call\n    async handleUserJoinedDuringCall(userId, userInfo) {\n        if (this.isInVideoCall && userId !== this.userId) {\n            this.roomParticipants.set(userId, userInfo);\n            \n            // Create peer connection and initiate call\n            await this.createPeerConnection(userId);\n            await this.makeCall(userId);\n        }\n    }\n    \n    // Enhanced handleUserJoined for video calls\n    handleUserJoined(data) {\n        const { user } = data;\n        console.log(`User joined room: ${user.name}`);\n        \n        this.roomParticipants.set(user.id, user);\n        \n        // If we're in a video call, establish peer connection\n        if (this.isInVideoCall) {\n            this.handleUserJoinedDuringCall(user.id, user);\n        }\n        \n        this.emit('user-joined', data);\n    }\n    \n    // Enhanced handleUserLeft for video calls  \n    handleUserLeft(data) {\n        const { userId } = data;\n        console.log(`User left room: ${userId}`);\n        \n        this.roomParticipants.delete(userId);\n        \n        // Clean up peer connection and remote stream\n        if (this.peerConnections.has(userId)) {\n            this.closePeerConnection(userId);\n        }\n        \n        if (this.remoteStreams.has(userId)) {\n            const stream = this.remoteStreams.get(userId);\n            stream.getTracks().forEach(track => track.stop());\n            this.remoteStreams.delete(userId);\n        }\n        \n        this.emit('user-left', data);\n    }\n    \n    // Enhanced createPeerConnection to handle remote streams\n    async createPeerConnection(userId) {\n        try {\n            if (this.peerConnections.has(userId)) {\n                console.log(`Peer connection already exists for user: ${userId}`);\n                return this.peerConnections.get(userId);\n            }\n\n            const peerConnection = new RTCPeerConnection(this.rtcConfiguration);\n            \n            // Add local stream tracks if available\n            if (this.localStream) {\n                this.localStream.getTracks().forEach(track => {\n                    peerConnection.addTrack(track, this.localStream);\n                });\n            }\n\n            // Handle incoming remote stream\n            peerConnection.ontrack = (event) => {\n                console.log('Received remote stream from user:', userId);\n                const [remoteStream] = event.streams;\n                this.remoteStreams.set(userId, remoteStream);\n                this.emit('remote-stream-added', { userId, stream: remoteStream });\n            };\n\n            // Handle ICE candidates\n            peerConnection.onicecandidate = (event) => {\n                if (event.candidate) {\n                    this.socket.emit('ice-candidate', {\n                        candidate: event.candidate,\n                        targetUserId: userId\n                    });\n                }\n            };\n\n            // Handle connection state changes\n            peerConnection.onconnectionstatechange = () => {\n                console.log(`Connection state with ${userId}:`, peerConnection.connectionState);\n                this.emit('connection-state-changed', { \n                    userId, \n                    state: peerConnection.connectionState \n                });\n                \n                if (peerConnection.connectionState === 'failed') {\n                    this.closePeerConnection(userId);\n                }\n            };\n\n            this.peerConnections.set(userId, peerConnection);\n            console.log(`Created peer connection for user: ${userId}`);\n            \n            return peerConnection;\n            \n        } catch (error) {\n            console.error(`Failed to create peer connection for user ${userId}:`, error);\n            this.emit('error', { type: 'peer_connection_failed', userId, error });\n            throw error;\n        }\n    }\n}\n\nexport default WebRTCService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}