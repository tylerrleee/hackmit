#!/usr/bin/env node
/**
 * Automated Ngrok Tunnel Setup Script
 * Creates Ngrok tunnels for backend, frontend, and bridge services
 * Updates configuration files dynamically
 */

const ngrok = require('ngrok');
const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const axios = require('axios');

class NgrokManager {
    constructor() {
        this.tunnels = {};
        this.processes = {};
        this.authToken = process.env.NGROK_AUTH_TOKEN;
    }

    async initialize() {
        console.log('üîß Initializing Ngrok tunnel manager...');
        
        if (!this.authToken) {
            console.error('‚ùå NGROK_AUTH_TOKEN not found in environment');
            console.log('Please set your Ngrok auth token:');
            console.log('export NGROK_AUTH_TOKEN="your_token_here"');
            process.exit(1);
        }

        // Set Ngrok auth token
        await ngrok.authtoken(this.authToken);
        console.log('‚úÖ Ngrok authentication configured');
    }

    async createTunnels() {
        console.log('üöÄ Creating Ngrok tunnels...');

        try {
            // Backend API (Express server on port 3001)
            console.log('   Creating backend tunnel...');
            const backendUrl = await ngrok.connect({
                proto: 'http',
                addr: 3001,
                region: 'us',
                bind_tls: true,
                name: 'backend'
            });
            this.tunnels.backend = backendUrl;
            console.log(`   ‚úÖ Backend: ${backendUrl}`);

            // Frontend (React dev server on port   export NGROK_AUTH_TOKEN=)
            console.log('   Creating frontend tunnel...');
            const frontendUrl = await ngrok.connect({
                proto: 'http', 
                addr: 3000,
                region: 'us',
                bind_tls: true,
                name: 'frontend'
            });
            this.tunnels.frontend = frontendUrl;
            console.log(`   ‚úÖ Frontend: ${frontendUrl}`);

            // Bridge WebSocket (Python bridge on port 8765)
            console.log('   Creating bridge WebSocket tunnel...');
            const bridgeWsUrl = await ngrok.connect({
                proto: 'http',
                addr: 8765,
                region: 'us', 
                bind_tls: true,
                name: 'bridge'
            });
            // Convert to WebSocket URL
            this.tunnels.bridge = bridgeWsUrl.replace('https://', 'wss://');
            console.log(`   ‚úÖ Bridge WebSocket: ${this.tunnels.bridge}`);

            // Bridge HTTP API (Python bridge on port 8766)
            console.log('   Creating bridge HTTP tunnel...');
            const bridgeHttpUrl = await ngrok.connect({
                proto: 'http',
                addr: 8766,
                region: 'us',
                bind_tls: true,
                name: 'bridge-http'
            });
            this.tunnels.bridgeHttp = bridgeHttpUrl;
            console.log(`   ‚úÖ Bridge HTTP: ${bridgeHttpUrl}`);

        } catch (error) {
            console.error('‚ùå Failed to create Ngrok tunnels:', error.message);
            throw error;
        }
    }

    async updateConfigurations() {
        console.log('üîÑ Updating configuration files...');

        try {
            // Update .env.external file
            await this.updateEnvExternal();
            console.log('   ‚úÖ Updated .env.external');

            // Update backend configuration (via API call)
            await this.updateBackendConfig();
            console.log('   ‚úÖ Notified backend of URL changes');

            // Create runtime configuration file for frontend
            await this.createRuntimeConfig();
            console.log('   ‚úÖ Created runtime configuration');

        } catch (error) {
            console.error('‚ùå Failed to update configurations:', error.message);
        }
    }

    async updateEnvExternal() {
        const envContent = `
# External Configuration for Ngrok Deployment
# Auto-generated by setup-ngrok.js

NODE_ENV=external
EXTERNAL_MODE=true

# Backend Configuration
API_BASE_URL=${this.tunnels.backend}
BACKEND_EXTERNAL_URL=${this.tunnels.backend}

# Frontend Configuration  
FRONTEND_EXTERNAL_URL=${this.tunnels.frontend}
CORS_ORIGIN=${this.tunnels.frontend}
REACT_APP_API_URL=${this.tunnels.backend}

# Bridge Configuration
AR_BRIDGE_URL=${this.tunnels.bridge}
AR_BRIDGE_HTTP_URL=${this.tunnels.bridgeHttp}
AR_BRIDGE_WS_PORT=8765
AR_BRIDGE_HTTP_PORT=8766

# External-specific settings
EXTERNAL_TIMEOUT=60000
CONNECTION_RETRY_ATTEMPTS=3
HEARTBEAT_INTERVAL=30000
RATE_LIMIT_MAX_REQUESTS=200

# Ngrok Configuration
NGROK_AUTH_TOKEN=${this.authToken}
NGROK_REGION=us
NGROK_BIND_TLS=true

# Generated at: ${new Date().toISOString()}
`.trim();

        fs.writeFileSync('.env.external', envContent);
    }

    async updateBackendConfig() {
        try {
            // Wait for backend to be available
            await this.waitForService(this.tunnels.backend + '/health', 'Backend');

            // Update backend configuration via API
            const response = await axios.post(this.tunnels.backend + '/api/external/update-urls', {
                backend: this.tunnels.backend,
                frontend: this.tunnels.frontend,
                bridge: this.tunnels.bridge,
                bridgeHttp: this.tunnels.bridgeHttp
            }, {
                timeout: 10000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            console.log('   Backend configuration updated successfully');
        } catch (error) {
            console.log('   ‚ö†Ô∏è  Backend configuration update failed (may not be implemented yet)');
        }
    }

    async createRuntimeConfig() {
        const runtimeConfig = {
            externalMode: true,
            apiBaseUrl: this.tunnels.backend,
            websocketUrl: this.tunnels.bridge,
            frontendUrl: this.tunnels.frontend,
            bridgeHttpUrl: this.tunnels.bridgeHttp,
            generatedAt: new Date().toISOString(),
            tunnels: this.tunnels
        };

        fs.writeFileSync('ngrok-config.json', JSON.stringify(runtimeConfig, null, 2));
    }

    async waitForService(url, serviceName, maxAttempts = 30) {
        console.log(`   Waiting for ${serviceName} to be available...`);
        
        for (let i = 0; i < maxAttempts; i++) {
            try {
                await axios.get(url, { timeout: 5000 });
                console.log(`   ‚úÖ ${serviceName} is available`);
                return;
            } catch (error) {
                console.log(`   ‚è≥ ${serviceName} not ready yet (attempt ${i + 1}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
        
        throw new Error(`${serviceName} did not become available within ${maxAttempts * 2} seconds`);
    }

    displayConfiguration() {
        console.log('\\nüéØ Ngrok Tunnel Configuration:');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log(`üì± Frontend URL:     ${this.tunnels.frontend}`);
        console.log(`üîß Backend API URL:  ${this.tunnels.backend}`);  
        console.log(`üåê Bridge WebSocket: ${this.tunnels.bridge}`);
        console.log(`üîå Bridge HTTP API:  ${this.tunnels.bridgeHttp}`);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('\\nüìã Quick Access Commands:');
        console.log(`   Frontend: open ${this.tunnels.frontend}`);
        console.log(`   API Test: curl ${this.tunnels.backend}/health`);
        console.log(`   Ngrok Web: open http://localhost:4040`);
        console.log('\\nüí° The system is now accessible from anywhere!');
        console.log('   Share the frontend URL with remote collaborators.');
        console.log('\\n‚ö†Ô∏è  Keep this terminal running to maintain tunnels.\\n');
    }

    async startServices() {
        console.log('üöÄ Starting services with external configuration...');

        // Set environment to external mode
        process.env.NODE_ENV = 'external';
        process.env.EXTERNAL_MODE = 'true';

        // Start backend with external config
        console.log('   Starting backend server...');
        const backendProcess = spawn('npm', ['run', 'dev'], {
            cwd: 'backend',
            stdio: ['inherit', 'pipe', 'pipe'],
            env: { ...process.env }
        });

        backendProcess.stdout.on('data', (data) => {
            console.log(`[BACKEND] ${data.toString().trim()}`);
        });

        backendProcess.stderr.on('data', (data) => {
            console.error(`[BACKEND ERROR] ${data.toString().trim()}`);
        });

        this.processes.backend = backendProcess;

        // Start bridge service
        console.log('   Starting WebRTC bridge...');
        const bridgeProcess = spawn('python', ['webrtc_bridge.py'], {
            stdio: ['inherit', 'pipe', 'pipe'],
            env: { ...process.env }
        });

        bridgeProcess.stdout.on('data', (data) => {
            console.log(`[BRIDGE] ${data.toString().trim()}`);
        });

        bridgeProcess.stderr.on('data', (data) => {
            console.error(`[BRIDGE ERROR] ${data.toString().trim()}`);
        });

        this.processes.bridge = bridgeProcess;

        // Give services time to start
        await new Promise(resolve => setTimeout(resolve, 5000));
    }

    async cleanup() {
        console.log('\\nüßπ Cleaning up Ngrok tunnels...');
        
        // Kill spawned processes
        Object.values(this.processes).forEach(proc => {
            if (proc && !proc.killed) {
                proc.kill();
            }
        });

        // Disconnect Ngrok tunnels
        await ngrok.disconnect();
        await ngrok.kill();
        
        console.log('‚úÖ Cleanup completed');
    }

    async run() {
        try {
            await this.initialize();
            await this.startServices();
            await this.createTunnels();
            await this.updateConfigurations();
            this.displayConfiguration();

            // Keep running until interrupted
            process.on('SIGINT', async () => {
                console.log('\\nüõë Shutting down...');
                await this.cleanup();
                process.exit(0);
            });

            process.on('SIGTERM', async () => {
                console.log('\\nüõë Received SIGTERM, shutting down...');
                await this.cleanup();
                process.exit(0);
            });

            // Keep process alive
            console.log('üîÑ Tunnels are active. Press Ctrl+C to stop.\\n');
            setInterval(() => {
                // Heartbeat to keep process alive
            }, 30000);

        } catch (error) {
            console.error('‚ùå Ngrok setup failed:', error.message);
            await this.cleanup();
            process.exit(1);
        }
    }
}

// Run the Ngrok manager
const manager = new NgrokManager();
manager.run().catch(error => {
    console.error('‚ùå Fatal error:', error.message);
    process.exit(1);
});